import mongoose from 'mongoose'
import { Story, Project, Feature, Sprint, MLPrediction, Activity, Notification } from '../models/index.js'
import {
  analyzeStoryComplexity,
  estimateStoryPoints as estimateStoryPointsService,
  findSimilarStories,
} from '../services/mlIntegration.service.js'
import { checkCircularDependency, getDependentStories } from '../services/dependency.service.js'
import { createActivity } from '../services/project.service.js'
import { sendStoryAssignedEmail } from '../services/email.service.js'
import eventEmitter from '../services/eventEmitter.service.js'
import { successResponse, paginatedResponse } from '../utils/response.js'
import { NotFoundError, BadRequestError, ForbiddenError } from '../utils/errors.js'
import { canViewProject } from '../utils/permissions.js'
import { sanitizeHTML } from '../utils/sanitize.js'
import logger from '../utils/logger.js'

/**
 * Story Controller
 * HTTP request handlers for stories
 */

/**
 * Create story
 * POST /api/projects/:projectId/stories or POST /api/features/:featureId/stories
 */
export const createStory = async (req, res, next) => {
  try {
    const { projectId, featureId } = req.params
    const storyData = req.body

    // Determine project ID
    let project = null
    if (projectId) {
      // Project access is already checked by checkProjectAccess middleware
      project = req.project || (await Project.findById(projectId).populate('team', '_id name'))
      if (!project) {
        throw new NotFoundError('Project not found')
      }
      storyData.project = projectId
    } else if (featureId) {
      const feature = await Feature.findById(featureId).populate({
        path: 'project',
        populate: { path: 'team', select: '_id name' },
      })
      if (!feature) {
        throw new NotFoundError('Feature not found')
      }
      project = feature.project
      
      // Check project access for feature's project
      if (!canViewProject(req.user, project)) {
        throw new ForbiddenError('You do not have access to this project')
      }
      
      storyData.project = feature.project._id
      storyData.feature = featureId
    } else {
      throw new BadRequestError('Project ID or Feature ID is required')
    }

    // Set createdBy
    storyData.createdBy = req.user.id

    // Create story (storyId will be auto-generated by pre-save hook)
    const story = new Story(storyData)
    await story.save()

    // Update feature's stories array if feature exists
    if (storyData.feature) {
      await Feature.findByIdAndUpdate(storyData.feature, {
        $addToSet: { stories: story._id },
      })
    }

    // Populate references
    await story.populate('project', 'name key')
    await story.populate('feature', 'title')
    await story.populate('assignedTo', 'name email avatar')
    await story.populate('createdBy', 'name email avatar')

    // Create activity log
    await createActivity({
      type: 'created',
      entityType: 'story',
      entityId: story._id,
      user: req.user.id,
      description: `Story "${story.title}" created`,
    })

    // Emit event via event emitter
    eventEmitter.emit('story:created', { story: story.toObject() })

    return successResponse(res, { story: story.toObject() }, 'Story created successfully', 201)
  } catch (error) {
    next(error)
  }
}

/**
 * Get stories with filters
 * GET /api/projects/:projectId/stories
 */
export const getStories = async (req, res, next) => {
  try {
    const { projectId } = req.params
    let { sprintId, status, assignedTo, search, page = 1, limit = 10 } = req.query
    
    // Map 'todo' status to 'backlog' for backward compatibility
    if (status === 'todo') {
      status = 'backlog'
    }

    // Project access is already checked by checkProjectAccess middleware
    // Use req.project if available, otherwise fetch it
    const project = req.project || (await Project.findById(projectId))
    if (!project) {
      throw new NotFoundError('Project not found')
    }

    // Build query
    const query = { project: projectId }

    if (sprintId) {
      query.sprint = sprintId
    }

    if (status) {
      query.status = status
    }

    if (assignedTo) {
      query.assignedTo = assignedTo
    }

    if (search) {
      query.$or = [
        { title: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } },
        { storyId: { $regex: search, $options: 'i' } },
      ]
    }

    // Calculate pagination
    const skip = (parseInt(page) - 1) * parseInt(limit)
    // For developers, increase limit to show more stories (they're already filtered)
    const limitNum = req.user.role === 'developer' 
      ? Math.max(parseInt(limit) || 10, 100) // At least 100 for developers
      : parseInt(limit) || 10

    // For developers, we need to filter stories that have tasks assigned to them
    // First, get all stories, then filter by tasks if needed
    let storiesQuery = Story.find(query)
      .populate('assignedTo', 'name email avatar')
      .populate('feature', 'title')
      .populate('sprint', 'name status')
    
    // For developers, populate tasks to filter by assigned tasks
    if (req.user.role === 'developer') {
      storiesQuery = storiesQuery.populate({
        path: 'tasks',
        select: 'title status assignedTo',
        match: { assignedTo: req.user._id || req.user.id },
      })
    } else {
      // For other roles, populate all tasks (or just basic info)
      storiesQuery = storiesQuery.populate({
        path: 'tasks',
        select: 'title status assignedTo',
        options: { limit: 10 }, // Limit to avoid huge payloads
      })
    }
    
    // Execute query
    const [stories, total] = await Promise.all([
      storiesQuery
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limitNum)
        .lean(),
      Story.countDocuments(query),
    ])
    
    // For developers, filter out stories that have no tasks assigned to them
    let filteredStories = stories
    if (req.user.role === 'developer') {
      const userId = req.user._id || req.user.id
      filteredStories = stories.filter((story) => {
        // Story is included if:
        // 1. It has tasks assigned to this developer, OR
        // 2. The story itself is assigned to this developer
        const hasAssignedTasks = story.tasks && story.tasks.length > 0
        const isStoryAssigned = story.assignedTo && 
          (story.assignedTo._id?.toString() === userId.toString() || 
           story.assignedTo.toString() === userId.toString())
        return hasAssignedTasks || isStoryAssigned
      })
    }

    // Calculate pagination info (use filtered count for developers)
    const actualTotal = req.user.role === 'developer' ? filteredStories.length : total
    const totalPages = Math.ceil(actualTotal / limitNum)
    const pagination = {
      page: parseInt(page),
      limit: limitNum,
      total: actualTotal,
      totalPages,
      hasNext: parseInt(page) < totalPages,
      hasPrev: parseInt(page) > 1,
    }

    return paginatedResponse(res, filteredStories, pagination, 'Stories retrieved successfully')
  } catch (error) {
    next(error)
  }
}

/**
 * Get single story
 * GET /api/stories/:id
 */
export const getStory = async (req, res, next) => {
  try {
    const { id } = req.params

    const story = await Story.findById(id)
      .populate('project', 'name key')
      .populate('feature', 'title')
      .populate('sprint', 'name status startDate endDate')
      .populate('assignedTo', 'name email avatar')
      .populate('dependencies', 'title storyId status')
      .populate('tasks', 'title status assignedTo')
      .populate('createdBy', 'name email avatar')

    if (!story) {
      throw new NotFoundError('Story not found')
    }

    return successResponse(res, { story: story.toObject() }, 'Story retrieved successfully')
  } catch (error) {
    next(error)
  }
}

/**
 * Update story
 * PUT /api/stories/:id
 */
export const updateStory = async (req, res, next) => {
  try {
    const { id } = req.params
    const updateData = req.body

    // Find story
    const story = await Story.findById(id)
    if (!story) {
      throw new NotFoundError('Story not found')
    }

    // Track assignment change for email
    const oldAssignedTo = story.assignedTo?.toString()
    const newAssignedTo = updateData.assignedTo?.toString()
    const assignmentChanged = newAssignedTo && newAssignedTo !== oldAssignedTo

    // Sanitize HTML content if description is being updated
    if (updateData.description) {
      updateData.description = sanitizeHTML(updateData.description)
    }

    // Track status and assignee changes
    const oldStatus = story.status
    const oldAssigneeId = story.assignedTo?.toString()
    
    // Update story
    Object.assign(story, updateData)
    await story.save()

    // Update developer metrics if status changed to 'done' or assignee changed
    if (oldStatus !== story.status || oldAssigneeId !== (story.assignedTo?.toString() || story.assignedTo)) {
      const { updateAllDeveloperMetrics } = await import('../services/developerMetrics.service.js')
      
      // Update old assignee if changed
      if (oldAssigneeId && oldAssigneeId !== (story.assignedTo?.toString() || story.assignedTo)) {
        await updateAllDeveloperMetrics(oldAssigneeId)
      }
      
      // Update new/current assignee
      if (story.assignedTo) {
        const assigneeId = story.assignedTo._id?.toString() || story.assignedTo.toString() || story.assignedTo
        await updateAllDeveloperMetrics(assigneeId)
      }
    }

    // Update project progress if story status changed
    if (oldStatus !== story.status && story.project) {
      const { updateProjectProgress } = await import('../services/project.service.js')
      const projectId = story.project._id?.toString() || story.project.toString() || story.project
      await updateProjectProgress(projectId)
    }

    // Populate references
    await story.populate('project', 'name key')
    await story.populate('assignedTo', 'name email avatar')

    // Send email if story was assigned
    if (assignmentChanged && story.assignedTo) {
      try {
        await Notification.create({
          user: story.assignedTo._id || story.assignedTo,
          type: 'story_assigned',
          title: 'Story Assigned',
          message: `You have been assigned to story "${story.title}"`,
          entityType: 'story',
          entityId: story._id,
        })

        sendStoryAssignedEmail(
          story.assignedTo._id || story.assignedTo,
          story,
          story.project
        ).catch((err) => {
          logger.error('Error sending story assigned email:', err)
        })
      } catch (err) {
        logger.error('Error preparing story assigned email:', err)
      }
    }

    // Create activity log
    await createActivity({
      type: 'updated',
      entityType: 'story',
      entityId: story._id,
      user: req.user.id,
      description: `Story "${story.title}" updated`,
      metadata: { changes: updateData },
    })

    // Emit event via event emitter
    eventEmitter.emit('story:updated', { story: story.toObject() })

    return successResponse(res, { story: story.toObject() }, 'Story updated successfully')
  } catch (error) {
    next(error)
  }
}

/**
 * Delete story
 * DELETE /api/stories/:id
 */
export const deleteStory = async (req, res, next) => {
  try {
    const { id } = req.params

    // Find story
    const story = await Story.findById(id)
    if (!story) {
      throw new NotFoundError('Story not found')
    }

    // Check for dependent stories
    const dependentStories = await getDependentStories(id)
    if (dependentStories.length > 0) {
      throw new BadRequestError(
        `Cannot delete story. ${dependentStories.length} story/stories depend on this story.`
      )
    }

    // Remove from sprint if assigned
    if (story.sprint) {
      await Sprint.findByIdAndUpdate(story.sprint, {
        $pull: { stories: id },
      })
    }

    // Remove from feature if assigned
    if (story.feature) {
      await Feature.findByIdAndUpdate(story.feature, {
        $pull: { stories: id },
      })
    }

    // Delete story
    await Story.findByIdAndDelete(id)

    // Create activity log
    await createActivity({
      type: 'deleted',
      entityType: 'story',
      entityId: id,
      user: req.user.id,
      description: `Story "${story.title}" deleted`,
    })

    // Emit event via event emitter
    eventEmitter.emit('story:deleted', {
      storyId: id,
      projectId: story.project,
      sprintId: story.sprint,
    })

    return successResponse(res, null, 'Story deleted successfully')
  } catch (error) {
    next(error)
  }
}

/**
 * Analyze story complexity using AI
 * POST /api/stories/:id/analyze
 */
export const analyzeStory = async (req, res, next) => {
  try {
    const { id } = req.params

    // Find story
    const story = await Story.findById(id).populate('project', 'name key')
    if (!story) {
      throw new NotFoundError('Story not found')
    }

    // Call ML service
    let aiInsights = null
    try {
      aiInsights = await analyzeStoryComplexity({
        title: story.title,
        description: story.description,
        acceptanceCriteria: story.acceptanceCriteria,
        projectId: story.project._id.toString(),
      })
    } catch (mlError) {
      logger.error('ML service error:', mlError)
      throw new BadRequestError('Failed to analyze story. ML service unavailable.')
    }

    const breakdown = aiInsights.breakdown || aiInsights.complexityBreakdown || {}
    const normalizedBreakdown = {
      ui: breakdown.ui_complexity ?? breakdown.ui ?? 0,
      backend: breakdown.backend_complexity ?? breakdown.backend ?? 0,
      integration: breakdown.integration_complexity ?? breakdown.integration ?? 0,
      testing: breakdown.testing_complexity ?? breakdown.testing ?? 0,
    }

    const similarStories = (aiInsights.similar_stories || []).map((item) => ({
      storyId: item.story_id || item.storyId || null,
      title: item.title,
      similarity: item.similarity ?? 0,
      actualPoints: item.actual_points ?? item.actualPoints ?? null,
      actualTime: item.actual_time ?? item.actualTime ?? null,
    }))

    const recommendedPoints =
      aiInsights.estimated_story_points ?? aiInsights.estimatedPoints ?? story.storyPoints

    // Update story with AI insights
    story.aiInsights = {
      complexity: aiInsights.complexity_score ?? aiInsights.complexity ?? 0,
      complexityScore: aiInsights.complexity_score ?? aiInsights.complexity ?? 0,
      complexityLevel: aiInsights.complexity_level || 'medium',
      complexityBreakdown: normalizedBreakdown,
      estimatedPoints: recommendedPoints || 0,
      confidence: aiInsights.confidence ?? aiInsights.estimatedEffort?.confidence ?? 0,
      factors: aiInsights.factors || [],
      requirements: aiInsights.requirements_extracted || [],
      similarStories,
      analyzedAt: new Date(),
      modelVersion: aiInsights.model_version || '1.0',
    }

    // Update story points if estimated
    if (recommendedPoints && !story.storyPoints) {
      story.storyPoints = recommendedPoints
    }

    await story.save()

    // Create MLPrediction record
    await MLPrediction.create({
      type: 'complexity',
      entityId: story._id,
      entityType: 'story',
      prediction: aiInsights,
      confidence: aiInsights.confidence || 0,
      modelVersion: aiInsights.modelVersion || '1.0',
    })

    // Create activity log
    await createActivity({
      type: 'updated',
      entityType: 'story',
      entityId: story._id,
      user: req.user.id,
      description: `Story "${story.title}" analyzed by AI`,
      metadata: { aiInsights },
    })

    // Emit event via event emitter
    eventEmitter.emit('story:ai-analyzed', {
      storyId: id,
      story: story.toObject(),
      aiInsights: story.aiInsights,
    })

    return successResponse(
      res,
      { aiInsights: story.aiInsights },
      'Story analyzed successfully'
    )
  } catch (error) {
    next(error)
  }
}

/**
 * Estimate story points using AI
 * POST /api/stories/:id/estimate-points
 */
export const estimateStoryPoints = async (req, res, next) => {
  try {
    const { id } = req.params

    // Find story
    const story = await Story.findById(id).populate('project', 'name key')
    if (!story) {
      throw new NotFoundError('Story not found')
    }

    // Call ML service
    let estimation = null
    try {
      estimation = await estimateStoryPointsService({
        title: story.title,
        description: story.description,
        acceptanceCriteria: story.acceptanceCriteria,
        complexity: story.aiInsights?.complexity,
        projectId: story.project._id.toString(),
      })
    } catch (mlError) {
      logger.error('ML service error:', mlError)
      throw new BadRequestError('Failed to estimate story points. ML service unavailable.')
    }

    // Update story
    const points = estimation.estimated_story_points ?? estimation.storyPoints ?? story.storyPoints

    if (points) {
      story.storyPoints = points
    }

    if (!story.aiInsights) {
      story.aiInsights = {}
    }

    story.aiInsights.estimatedPoints = points || 0
    story.aiInsights.confidence = estimation.confidence ?? story.aiInsights.confidence ?? 0
    story.aiInsights.analyzedAt = new Date()

    await story.save()

    return successResponse(
      res,
      { storyPoints: story.storyPoints, confidence: estimation.confidence ?? 0 },
      'Story points estimated successfully'
    )
  } catch (error) {
    next(error)
  }
}

/**
 * Find similar stories
 * GET /api/stories/:id/similar
 */
export const findSimilarStoriesHandler = async (req, res, next) => {
  try {
    const { id } = req.params

    // Find story
    const story = await Story.findById(id)
    if (!story) {
      throw new NotFoundError('Story not found')
    }

    // Call ML service
    let similarStories = []
    try {
      similarStories = await findSimilarStories({
        title: story.title,
        description: story.description,
        acceptanceCriteria: story.acceptanceCriteria,
      })
    } catch (mlError) {
      logger.error('ML service error:', mlError)
      throw new BadRequestError('Failed to find similar stories. ML service unavailable.')
    }

    const validStoryIds = similarStories
      .map((s) => s.story_id || s.storyId)
      .filter((id) => id && mongoose.Types.ObjectId.isValid(id))

    let relatedStories = []
    if (validStoryIds.length > 0) {
      relatedStories = await Story.find({
        _id: { $in: validStoryIds },
      })
        .select('title storyId status storyPoints project')
        .populate('project', 'name key')
        .lean()
    }

    const storyMap = new Map(relatedStories.map((doc) => [doc._id.toString(), doc]))

    const storiesWithScores = similarStories.map((similar) => {
      const doc = storyMap.get(similar.story_id || '')
      return {
        storyId: doc?._id?.toString() || similar.story_id || null,
        storyKey: doc?.storyId || null,
        title: doc?.title || similar.title,
        project: doc?.project || null,
        similarity: similar.similarity ?? 0,
        actualPoints: doc?.storyPoints ?? similar.actual_points ?? null,
        actualTime: similar.actual_time ?? null,
      }
    })

    return successResponse(
      res,
      { similarStories: storiesWithScores },
      'Similar stories retrieved successfully'
    )
  } catch (error) {
    next(error)
  }
}

/**
 * Add dependency to story
 * POST /api/stories/:id/dependencies
 */
export const addDependency = async (req, res, next) => {
  try {
    const { id } = req.params
    const { dependencyId } = req.body

    // Find story
    const story = await Story.findById(id)
    if (!story) {
      throw new NotFoundError('Story not found')
    }

    // Find dependency story
    const dependencyStory = await Story.findById(dependencyId)
    if (!dependencyStory) {
      throw new NotFoundError('Dependency story not found')
    }

    // Check if same project
    if (story.project.toString() !== dependencyStory.project.toString()) {
      throw new BadRequestError('Dependency must be from the same project')
    }

    // Check for circular dependency
    const hasCircular = await checkCircularDependency(id, dependencyId)
    if (hasCircular) {
      throw new BadRequestError('Circular dependency detected. Cannot add this dependency.')
    }

    // Add dependency
    if (!story.dependencies.includes(dependencyId)) {
      story.dependencies.push(dependencyId)
      await story.save()
    }

    // Populate references
    await story.populate('dependencies', 'title storyId status')

    // Create activity log
    await createActivity({
      type: 'updated',
      entityType: 'story',
      entityId: story._id,
      user: req.user.id,
      description: `Dependency added to story "${story.title}"`,
    })

    return successResponse(res, { story: story.toObject() }, 'Dependency added successfully')
  } catch (error) {
    next(error)
  }
}

/**
 * Remove dependency from story
 * DELETE /api/stories/:id/dependencies/:dependencyId
 */
export const removeDependency = async (req, res, next) => {
  try {
    const { id, dependencyId } = req.params

    // Find story
    const story = await Story.findById(id)
    if (!story) {
      throw new NotFoundError('Story not found')
    }

    // Remove dependency
    story.dependencies = story.dependencies.filter(
      (dep) => dep.toString() !== dependencyId
    )
    await story.save()

    // Create activity log
    await createActivity({
      type: 'updated',
      entityType: 'story',
      entityId: story._id,
      user: req.user.id,
      description: `Dependency removed from story "${story.title}"`,
    })

    return successResponse(res, { story: story.toObject() }, 'Dependency removed successfully')
  } catch (error) {
    next(error)
  }
}

